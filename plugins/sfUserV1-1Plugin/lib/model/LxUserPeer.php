<?php


/**
 * Skeleton subclass for performing query and update operations on the 'lx_user' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.1 on:
 *
 * Tue Mar  9 09:57:10 2010
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.lynx
 */
class LxUserPeer extends BaseLxUserPeer {

    /**
     * Funcion para validar si los datos ingresado son correctos
     *
     * @param string $login
     * @param string $clave
     * @return array
     */
    public static function validateUserPanel($login, $clave)
    {
        $c = new Criteria();
        $c->add(self::LOGIN, $login);
        $c->add(self::PASSWORD, $clave);
        $c->add(self::STATUS, 1);
        
        return self::doSelectOne($c);
    }
    /**
      * Recupera la contrasena actual de un usuario
      *
      * @param integer $idUser
      * @return array
      */
    public static function getCurrentPassword($idUser)
    {
        $c = new Criteria();
        $c->add(self::ID_USER, $idUser);
        return self::doSelectOne($c);
        //Cambiar por return !empty($profiles) ? $profiles : false;
    }
    /**
     * Valida que el login no este duplicado
     * @param string $login
     * @param integer $idUser
     * @return integer
     */
    public static function validateLogin($login, $idUser = 0)
    {
        $c = new Criteria();
        
        $c->add(self::LOGIN, $login);
        if($idUser)
        {
            $c->add(self::ID_USER, $idUser, Criteria::NOT_EQUAL);
        }
        return self::doCount($c);
        
    }
    /**
     * Valida que no este duplicado el email do usuario
     * @param string $email
     * @param integer $idUser
     * @return integer
     */
    public static function validateEmail($email, $idUser = 0)
    {
        $c = new Criteria();
        
        $c->add(self::LOGIN, $email);
        if($idUser)
        {
            $c->add(self::ID_USER, $idUser, Criteria::NOT_EQUAL);
        }
        return self::doCount($c);
    }
    
    /**
     * Obtengo el perfil del usuario
     */
    public static function getPerfilActual($id_user) {
        $c =  new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Selecciona las columnas
        $c->addSelectColumn(self::ID_PROFILE);
        //Condicion
        $c->add(self::ID_USER,$id_user,Criteria::EQUAL);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch()) {
            $dato['id_profile'] = $res['ID_PROFILE'];            
        }        
        if (!empty($dato)) {
            return $dato;
        }else {
            return false;
        }
    }
    /**
     * Datos del usuario
     */
    public static function getDataUser($id_user) {
        $c =  new Criteria();
        //Eliminamos la columnas de seleccion en caso de que esten definidas
        $c->clearSelectColumns();
        //Selecciona las columnas
        $c->addSelectColumn(self::NAME);
        $c->addSelectColumn(self::EMAIL);
        //Condicion
        $c->add(self::ID_USER,$id_user,Criteria::EQUAL);
        //Ejecucion de consulta
        $rs = self::doSelectStmt($c);
        //Se recuperan los registros y se genera arreglo
        while($res = $rs->fetch()) {
            $dato['name']   = $res['NAME'];                              
            $dato['email']  = $res['EMAIL'];                              
        }        
        if (!empty($dato)) {
            return $dato;
        }else {
            return false;
        }
    }
    /**
     * Retorna los usuarios 
     * @param type $idUser
     * @return array
     */
    public static function getOtrosUsuarios($idUser)
    {
        $c = new Criteria();
        $c->add(self::ID_TIPO_USUARIO, 1, Criteria::GREATER_THAN);
        $c->add(self::ID_USER, $idUser, Criteria::NOT_EQUAL);
        return self::doSelect($c);
    }

} // LxUserPeer
